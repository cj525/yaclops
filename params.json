{"name":"Yaclops","tagline":"Yet another command-line options parser","body":"![](logo.png)\r\n\r\n# Yaclops #\r\n\r\nYet another command-line option parser.\r\n\r\n* Intended for cases where subcommands are required (like git or svn)\r\n* Nearly POCO classes: they need to inherit an interface and implement one method (`Execute()`).\r\n* Works well with IoC containers - resolve all command objects in one fell swoop\r\n* No dependencies\r\n\r\n## Examples ##\r\n\r\nFor each subcommand, implement a class that inherits the `ISubCommand` interface, which requires implementing one method (`Execute`) that is called to run the command. In your main function, create a `Parser` object and call `Parse(args)`, which will return the command to run. If no command is specified, the returned command will be a built-in `Help` command. Any errors (unknown command, for example) will throw a `CommandLineParserException`.\r\n\r\n\tusing Yaclops;\r\n\r\n    public class AddCommand : ISubCommand\r\n    {\r\n        [CommandLineOption(ShortName=\"n\")]\r\n        public bool DryRun { get; set; }\r\n\r\n        public void Execute()\r\n        {\r\n            // Execute the command....\r\n            Console.WriteLine(\"Add command!\");\r\n        }\r\n    }\r\n\r\n\r\n    static void Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            var parser = new CommandLineParser(new ISubCommand[] { new AddCommand(), new DiffCommand() });\r\n\r\n            var command = parser.Parse(args);\r\n\r\n            command.Execute();\r\n        }\r\n        catch (CommandLineParserException ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n    }\r\n\r\n\r\nCreating the commands is a little awkward, but the intent is that an IoC container, such as AutoFac, will be used, which makes it much cleaner:\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            try\r\n            {\r\n                var container = CreateContainer();\r\n\r\n                var parser = container.Resolve<CommandLineParser>();\r\n\r\n                var command = parser.Parse(args);\r\n\r\n                command.Execute();\r\n            }\r\n            catch (CommandLineParserException ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(\"Unhandled exception in main.\");\r\n                Console.WriteLine(ex);\r\n            }\r\n\r\n            if (Debugger.IsAttached)\r\n            {\r\n                Console.Write(\"<press ENTER to continue>\");\r\n                Console.ReadLine();\r\n            }\r\n        }\r\n\r\n\r\n\r\n        private static IContainer CreateContainer()\r\n        {\r\n            ContainerBuilder builder = new ContainerBuilder();\r\n\r\n            // Command-line specific stuff\r\n            builder.RegisterAssemblyTypes(Assembly.GetExecutingAssembly())\r\n                .Where(t => typeof(ISubCommand).IsAssignableFrom(t) && t.IsPublic)\r\n                .SingleInstance()\r\n                .As<ISubCommand>();\r\n\r\n            builder.RegisterType<CommandLineParser>();\r\n\r\n            return builder.Build();\r\n        }\r\n\r\nMore examples forthcoming. The included Sample project has additional examples.\r\n\r\n\r\n## Links ##\r\n\r\n* [Other Libraries](OtherLibraries.md)\r\n* [Todo List](ToDo.md)","google":"UA-53335216-2","note":"Don't delete this file! It's used internally to help with page regeneration."}